import React from 'react';
import 'antd/dist/antd.css';
import {Typography} from 'antd';
import SyntaxHighlighter from "react-syntax-highlighter";
import {darcula} from "react-syntax-highlighter/dist/esm/styles/hljs";

const {Paragraph, Text, Title} = Typography;

export default class Jdbc extends React.Component {
    render() {
        return (
            <Typography>
                <Title>JDBC</Title>
                <Paragraph style={{fontSize: 20}}>
                    <Text code>JDBC</Text> предоставляет вполне достаточный интерфейс для работы с базами данных в <Text code>Java</Text>.
                    Однако этот интерфейс весьма многословен и довольно неудобен и даже <Text code>Spring JDBC</Text> не делает его сильно лучше.
                    По сути дела проблема в том, что реляционные базы данных работают с таблицами и отношениями между ними, в то время как в <Text code>Java</Text> работают с объектами и их иерархиями.
                    Поэтому приходится для каждого объекта или таблицы писать класс отображения одного в другое. Этот процесс называется ORM — object-relational mapping (объектно-реляционное отображение).
                    И, к счастью, существуют готовые <Text code>ORM решения</Text>, которые сами переводят данные из одного вида в другой и обратно.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Более того, таких решений настолько много, что даже появился стандартный интерфейс JPA — Java persistence API,
                    который направлен на стандартизацию ORM продуктов и
                    описывает требования к объектам, для сохранения их в базах данных, интерфейсы для сохранения объектов и интерфейсы для получения объектов из БД.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    DAO (data access object) — один из наиболее распространенных паттернов проектирования, "Доступ к данным". Его смысл прост — создать в приложении слой, который отвечает только за доступ к данным, и больше ни за что. Достать данные из БД, обновить данные, удалить данные — и все.
                </Paragraph>
                <Title level={2}>Драйвер JDBC</Title>
                <Paragraph style={{fontSize: 20}}>
                    Драйвер JDBC - это реализация API JDBC, используемая для подключения к базе данных определенного типа. Чтобы подключиться к базе данных, нам просто нужно инициализировать драйвер и открыть соединение с базой данных.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Первый шаг. Подключаем зависимость
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"<dependency>\n" +
                    "    <groupId>mysql</groupId>\n" +
                    "    <artifactId>mysql-connector-java</artifactId>\n" +
                    "    <version>6.0.6</version>\n" +
                    "</dependency>"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    Второй шаг. зарегистрируем драйвер, используя метод Class.forName() , который динамически загружает класс драйвера
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Третий шаг. Чтобы открыть соединение, мы можем использовать метод getConnection () класса DriverManager . Этот метод требует подключения URL String параметр:
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"Connection con = DriverManager\n" +
                    "  .getConnection(\"jdbc:mysql://localhost:3306/myDb\", \"user1\", \"pass\");"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    Четвертый шаг. Мы можем создать стацтмен и передать в execute тело sql запроса, либо создать preparedStatement и передать его туда
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Пятый шаг. У нас есть ResultSet, считываем построчно с помощью метода next, если он возвращает true то у нас есть следующая строка и берем значению по типу и названию столбца например getString("name") можем это значение замапить т.е. положить на объект
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Шестой шаг. Когда мы больше не используем, необходимо закрыть соединение, чтобы освободить ресурсы базы данных. Это можно сделать с помощью API close ()
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    con.close();
                </SyntaxHighlighter>
                <Title level={2}>Statement и PreparedStatement</Title>
                <Paragraph style={{fontSize: 20}}>
                    JDBC API Statement используется для выполнения SQL запросов к базе данных.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Объект PreparedStatement используется для выполнения прекомпилированных SQL-запросов с или без входных (IN) параметров. Мы можем использовать сеттеры для установки значений в запрос. Т.к. PreparedStatement является предкомпилированным, то он может быть эффективно использован множество раз. PreparedStatement считается лучшим выбором нежели Statement, т.к. он автоматически обрабатывает специальные символы, а так же предотвращает, так называемые, SQL injection attack (когда в запрос можно подставить свой код).
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    <ul>
                        <li>PreparedStatement позволяет предотвратить атаки типа SQL injection, т.к. он автоматически экранирует специальные символы.</li>
                        <li>PreparedStatement позволяет использовать динамические запросы с внедрением параметров.</li>
                        <li>PreparedStatement быстрее Statement. Это особенно заметно при частом использовании PreparedStatement или при использовании для вызова группы запросов.</li>
                        <li>PreparedStatement позволяет писать объектно ориентированный код с использованием сеттеров\геттеров. В то время при использовании Statement необходимо использовать конкатенацию строк для создания запроса. Для больших запросов конкатенация выглядит, как минимум, большой, а так же несет в себе большой риск ошибки в запросе.</li>
                    </ul>
                </Paragraph>
                <Title level={2}>ResultSet</Title>
                <Paragraph style={{fontSize: 20}}>
                    JDBC ResultSet – интерфейс, объект которого создается в результате запроса к базе данных. Его можно представить в виде таблицы данных, которая была сформирована в ответ на запрос.
                    Объект ResultSet поддерживает курсор, который указывает на текущую строку данных. При инициализации курсор устанавливается до первой строки. Для движение по строкам используется метод next(). При наличии строк после текущей позиции, метод next() возвращает true, что можно использовать для итерации по таблице полученных результатов.
                </Paragraph>

                <Title level={2}>Transaction Management</Title>
                <Paragraph style={{fontSize: 20}}>
                    По умолчанию, при создании подключения к базе данных будет выбран auto-commit mode. Это означает, что при каждом выполнении запроса он будет подтвержден автоматически по завершению. Каждый SQL запрос является транзакционным и выполняя какие-либо DML или DDL запросы по их завершению изменения будут приняты (сохранены) базой данных. Если у нас есть необходимость отказываться от сохранения выполнения какого-либо запроса (или групп запросов) в случае, если что-то пошло не так, то мы можем воспользоваться поддержкой транзакций в JDBC API.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    С помощью метода setAutoCommit(boolean flag) можно отключить авто коммит в конкретном соединении. Следует отметить, что при отключении auto-commit не одно изменение не будет сохранено в базе данных до вызова метода commit() и за этим необходимо следить. Сервер базы данных будет блокировать необходимую часть базы данных до подтверждения транзакции, а так как это ресурсоёмкая задача, то подтверждать транзакцию необходимо сразу после выполнения задачи.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Для того чтобы откатить транзакцию используется  rollback(), который откатывает транзакцию. Будут отменены все изменения в транзакции и отменен lock базы данных от этого объекта Connection.
                </Paragraph>
                <Title>JPA</Title>
                <Paragraph style={{fontSize: 20}}>
                    Сам <Text code>JPA</Text> является лишь описательным стандартом и пачкой аннотаций, описывающая систему управления сохранением java объектов в таблицы реляционных баз данных в удобном виде, поэтому у него есть несколько реализаций.
                    Одна из самых популярных и, в то же время, одна из не самых стандартных реализаций, называется <Text code>Hibernate</Text>.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    В JPA описаны два типа fetch стратегии:
                    <ul>
                        <li>LAZY — данные поля будут загружены только во время первого доступа к этому полю</li>
                        <li>EAGER — данные поля будут загружены немедленно</li>
                    </ul>
                </Paragraph>
            </Typography>)
    }
}