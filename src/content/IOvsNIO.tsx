import React from 'react';
import 'antd/dist/antd.css';
import {Table, Typography} from 'antd';

const {Paragraph, Text, Title} = Typography;

export default class IOvsNIO extends React.Component {
    render() {
        return (
            <Typography>
                <Table pagination={false}
                       style={{marginTop:15}}
                       dataSource={[
                           {
                               io: 'Потокоориентированный',
                               nio: 'Буфер-ориентированный'
                           },
                           {
                               io: 'Блокирующий (синхронный) ввод/вывод',
                               nio: 'Неблокирующий (асинхронный) ввод/вывод'
                           },
                           {
                               nio: 'Селекторы'
                           }
                       ]}
                       columns={[
                           {
                               title: 'IO',
                               dataIndex: 'io'
                           },
                           {
                               title: 'NIO',
                               dataIndex: 'nio'
                           }
                       ]}>
                </Table>
                <Title>Потокоориентированный и буфер-ориентированный ввод/вывод</Title>
                <Paragraph style={{fontSize: 20}}>
                    Потокоориентированный ввод/вывод подразумевает чтение/запись из потока/в поток одного или нескольких байт в единицу времени поочередно. Данная информация нигде не кэшируются. Таким образом, невозможно произвольно двигаться по потоку данных вперед или назад. Если вы хотите произвести подобные манипуляции, вам придется сначала кэшировать данные в буфере.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Подход, на котором основан Java NIO немного отличается. Данные считываются в буфер для последующей обработки. Вы можете двигаться по буферу вперед и назад. Это дает немного больше гибкости при обработке данных. В то же время, вам необходимо проверять содержит ли буфер необходимый для корректной обработки объем данных. Также необходимо следить, чтобы при чтении данных в буфер вы не уничтожили ещё не обработанные данные, находящиеся в буфере.
                </Paragraph>
                <Title>Блокирующий и неблокирующий ввод/вывод</Title>
                <Paragraph style={{fontSize: 20}}>
                    Потоки ввода/вывода (streams) в Java IO являются блокирующими. Это значит, что когда в потоке выполнения (tread) вызывается <Text code>read()</Text> или <Text code>write()</Text> метод любого класса из пакета <Text code>java.io.*</Text>, происходит блокировка до тех пор, пока данные не будут считаны или записаны. Поток выполнения в данный момент не может делать ничего другого.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала (channel) и получать только то, что доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, чтобы оставаться заблокированным пока данные не станут доступными для считывания, поток выполнения может заняться чем-то другим.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Каналы напоминают трубопроводы, по которым эффективно транспортируются данные между буферами байтов и сущностями по ту сторону каналов. Каналы – это шлюзы, которые позволяют получить доступ к сервисам ввода/вывода операционной системы с минимальными накладными расходами, а буферы – внутренние конечные точки этих шлюзов, используемые для передачи и приема данных.
                </Paragraph>
                <Title>Селекторы</Title>
                <Paragraph style={{fontSize: 20}}>
                    Селекторы в Java NIO позволяют одному потоку выполнения мониторить несколько каналов ввода. Вы можете зарегистрировать несколько каналов с селектором, а потом использовать один поток выполнения для обслуживания каналов, имеющих доступные для обработки данные, или для выбора каналов, готовых для записи.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Чтобы лучше понять концепцию и выгоду от применения селекторов, давайте абстрагируемся от программирования и представим себе железнодорожный вокзал. Вариант без селектора: есть три железнодорожных пути (каналы), на каждый из них в любой момент времени может прибыть поезд (данные из буфера), на каждом пути постоянно ожидает сотрудник вокзала (поток выполнения), задача которого – обслуживание прибывшего поезда. В результате трое сотрудников постоянно находятся на вокзале даже если там вообще нет поездов. Вариант с селектором: ситуация та же, но для каждой платформы есть индикатор, сигнализирующий сотруднику вокзала (поток выполнения) о прибытии поезда. Таким образом на вокзале достаточно присутствия одного сотрудника.
                </Paragraph>
                <Title>Итоги</Title>
                <Paragraph style={{fontSize: 20}}>
                    Если вам необходимо управлять тысячами открытых соединений одновременно, причем каждое из них передает лишь незначительный объем данных, выбор Java NIO для вашего приложения может дать преимущество.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Если вы имеете меньшее количество соединений, по которым передаются большие объемы данных, то лучшим выбором станет классический дизайн системы ввода/вывода
                </Paragraph>
            </Typography>)
    }
}