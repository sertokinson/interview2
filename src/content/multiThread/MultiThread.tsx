import React from 'react';
import 'antd/dist/antd.css';
import {Typography, Image} from 'antd';
import SyntaxHighlighter from "react-syntax-highlighter";
import {darcula} from "react-syntax-highlighter/dist/esm/styles/hljs";

import blocked from "./blocked.png";

const {Paragraph, Title, Text} = Typography;

export default class MultiThread extends React.Component {
    render() {
        return (
            <Typography>
                <Title>Процесс</Title>
                <Paragraph style={{fontSize: 20}}>
                    Процесс создается операционной системой, когда пользователь запускает приложение. Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.
                </Paragraph>
                <Title>Поток</Title>
                <Paragraph style={{fontSize: 20}}>
                    Один поток – это одна единица исполнения кода. Каждый поток последовательно выполняет инструкции процесса, которому он принадлежит, параллельно с другими потоками этого процесса.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Следует отдельно обговорить фразу «параллельно с другими потоками». Известно, что на одно ядро процессора, в каждый момент времени, приходится одна единица исполнения. То есть одноядерный процессор может обрабатывать команды только последовательно, по одной за раз (в упрощенном случае). Однако запуск нескольких параллельных потоков возможен и в системах с одноядерными процессорами. В этом случае система будет периодически переключаться между потоками, поочередно давая выполняться то одному, то другому потоку. Такая схема называется псевдо-параллелизмом. Система запоминает состояние (контекст) каждого потока, перед тем как переключиться на другой поток, и восстанавливает его по возвращению к выполнению потока
                </Paragraph>
                <Title>Запуск потоков</Title>
                <Paragraph style={{fontSize: 20}}>
                    Каждый процесс имеет хотя бы один выполняющийся поток.
                    Тот поток, с которого начинается выполнение программы, называется главным.
                    после создания процесса, выполнение главного потока начинается с метода <Text code>main()</Text>.
                    Затем, по мере необходимости, в заданных программистом местах, и при выполнении заданных им же условий, запускаются другие
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    поток представляется в виде объекта-потомка класса <Text code>Thread</Text>. Этот класс инкапсулирует стандартные механизмы работы с потоком.
                </Paragraph>
                <Title level={2}>Способ 1</Title>
                <Paragraph style={{fontSize: 20}}>
                    Создать объект класса <Text code>Thread</Text>, передав ему в конструкторе нечто, реализующее интерфейс <Text code>Runnable</Text>.
                    Этот интерфейс содержит метод <Text code>run()</Text>, который будет выполняться в новом потоке. Поток закончит выполнение, когда завершится его метод <Text code>run()</Text>.
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"class SomeThing implements Runnable { //Нечто, реализующее интерфейс Runnable (содержащее метод run())\n" +
                    "\tpublic void run() {\t\t//Этот метод будет выполняться в побочном потоке\n" +
                    "\t\tSystem.out.println(\"Привет из побочного потока!\");\n" +
                    "\t}\n" +
                    "}\n" +
                    "\n" +
                    "public class Program {\t\t\t//Класс с методом main()\n" +
                    "\tstatic SomeThing mThing;\t//mThing - объект класса, реализующего интерфейс Runnable\n" +
                    "\t\n" +
                    "\tpublic static void main(String[] args) {\n" +
                    "\t\tmThing = new SomeThing();\t\t\t\t\n" +
                    "\n" +
                    "\t\tThread myThready = new Thread(mThing);\t//Создание потока \"myThready\"\n" +
                    "\t\tmyThready.start();\t\t\t\t//Запуск потока\n" +
                    "\n" +
                    "\t\tSystem.out.println(\"Главный поток завершён...\");\n" +
                    "\t}\n" +
                    "}"}
                </SyntaxHighlighter>
                <Title level={2}>Способ 2</Title>
                <Paragraph style={{fontSize: 20}}>
                    Создать потомка класса Thread и переопределить его метод run():
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"class AffableThread extends Thread {\n" +
                    "    @Override\n" +
                    "    public void run() {\n" +
                    "        System.out.println(\"Привет из побочного потока!\");\n" +
                    "    }\n" +
                    "}\n" +
                    "\n" +
                    "public class CreateThread2 {\n" +
                    "    static AffableThread mSecondThread;\n" +
                    "\n" +
                    "    public static void main(String[] args) {\n" +
                    "        mSecondThread = new AffableThread();\t//Создание потока\n" +
                    "        mSecondThread.start();\t\t\t\t\t//Запуск потока\n" +
                    "\n" +
                    "        System.out.println(\"Главный поток завершён...\");\n" +
                    "    }\n" +
                    "}"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    В приведённом выше примере в методе <Text code>main()</Text> создается и запускается еще один поток.
                    Важно отметить, что после вызова метода <Text code>mSecondThread.start()</Text> главный поток продолжает своё выполнение,
                    не дожидаясь пока порожденный им поток завершится. И те инструкции, которые идут после вызова метода <Text code>start()</Text>,
                    будут выполнены параллельно с инструкциями потока <Text code>mSecondThread</Text>.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Для демонстрации параллельной работы потоков давайте рассмотрим программу, в которой два потока спорят на предмет философского вопроса «что было раньше, яйцо или курица?».
                    Главный поток уверен, что первой была курица, о чем он и будет сообщать каждую секунду. Второй же поток раз в секунду будет опровергать своего оппонента.
                    Всего спор продлится 5 секунд. Победит тот поток, который последним изречет свой ответ на этот, без сомнения, животрепещущий философский вопрос.
                    В примере используются средства, о которых пока не было сказано (<Text code>isAlive()</Text> <Text code>sleep()</Text> и <Text code>join()</Text>).
                    К ним даны комментарии, а более подробно они будут разобраны дальше.
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"class EggVoice extends Thread {\n" +
                    "    @Override\n" +
                    "    public void run() {\n" +
                    "        for (int i = 0; i < 5; i++) {\n" +
                    "            try {\n" +
                    "                sleep(1000);        //Приостанавливает поток на 1 секунду\n" +
                    "            } catch (InterruptedException e) {\n" +
                    "            }\n" +
                    "\n" +
                    "            System.out.println(\"яйцо!\");\n" +
                    "        }\n" +
                    "        //Слово «яйцо» сказано 5 раз\n" +
                    "    }\n" +
                    "}\n" +
                    "\n" +
                    "public class TwoThread {\n" +
                    "    static EggVoice mAnotherOpinion;    //Побочный поток\n" +
                    "\n" +
                    "    public static void main(String[] args) {\n" +
                    "        mAnotherOpinion = new EggVoice();    //Создание потока\n" +
                    "        System.out.println(\"Спор начат...\");\n" +
                    "        mAnotherOpinion.start();            //Запуск потока\n" +
                    "\n" +
                    "        for (int i = 0; i < 5; i++) {\n" +
                    "            try {\n" +
                    "                Thread.sleep(1000);        //Приостанавливает поток на 1 секунду\n" +
                    "            } catch (InterruptedException e) {\n" +
                    "            }\n" +
                    "\n" +
                    "            System.out.println(\"курица!\");\n" +
                    "        }\n" +
                    "\n" +
                    "        //Слово «курица» сказано 5 раз\n" +
                    "\n" +
                    "        if (mAnotherOpinion.isAlive()) {   //Если оппонент еще не сказал последнее слово\n" +
                    "            try {\n" +
                    "                mAnotherOpinion.join();    //Подождать пока оппонент закончит высказываться.\n" +
                    "            } catch (InterruptedException e) {\n" +
                    "            }\n" +
                    "\n" +
                    "            System.out.println(\"Первым появилось яйцо!\");\n" +
                    "        } else {  //если оппонент уже закончил высказываться\n" +
                    "\n" +
                    "            System.out.println(\"Первой появилась курица!\");\n" +
                    "        }\n" +
                    "        System.out.println(\"Спор закончен!\");\n" +
                    "    }\n" +
                    "}"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    В приведенном примере два потока параллельно в течении 5 секунд выводят информацию на консоль. Точно предсказать, какой поток закончит высказываться последним, невозможно. Можно попытаться, и можно даже угадать, но есть большая вероятность того, что та же программа при следующем запуске будет иметь другого «победителя». Это происходит из-за так называемого «асинхронного выполнения кода». Асинхронность означает то, что нельзя утверждать, что какая-либо инструкция одного потока, выполнится раньше или позже инструкции другого. Или, другими словами, параллельные потоки независимы друг от друга, за исключением тех случаев, когда программист сам описывает зависимости между потоками с помощью предусмотренных для этого средств языка.
                </Paragraph>
                <Title>Завершение процесса и демоны</Title>
                <Paragraph style={{fontSize: 20}}>
                    процесс завершается тогда, когда завершается последний его поток. Даже если метод <Text code>main()</Text> уже завершился, но еще выполняются порожденные им потоки, система будет ждать их завершения.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Однако это правило не относится к особому виду потоков – демонам. Если завершился последний обычный поток процесса, и остались только потоки-демоны, то они будут принудительно завершены и выполнение процесса закончится. Чаще всего потоки-демоны используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод <Text code>setDaemon(true);</Text>
                    Проверить, является ли поток демоном, можно вызвав его метод <Text code>boolean isDaemon();</Text>
                </Paragraph>
                <Title>Завершение потоков</Title>
                <Paragraph style={{fontSize: 20}}>
                    В <Text code>Java</Text> существуют (существовали) средства для принудительного завершения потока.
                    В частности метод <Text code>Thread.stop()</Text> завершает поток незамедлительно после своего выполнения.
                    Однако этот метод, а также <Text code>Thread.suspend()</Text>, приостанавливающий поток, и <Text code>Thread.resume()</Text>,
                    продолжающий выполнение потока, были объявлены устаревшими и их использование отныне крайне нежелательно.
                    Дело в том что поток может быть «убит» во время выполнения операции, обрыв которой на полуслове оставит некоторый объект в неправильном состоянии,
                    что приведет к появлению трудноотлавливаемой и случайным образом возникающей ошибке.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Вместо принудительного завершения потока применяется схема, в которой каждый поток сам ответственен за своё завершение.
                    Поток может остановиться либо тогда, когда он закончит выполнение метода <Text code>run()</Text>, (main() — для главного потока)
                    либо по сигналу из другого потока. Причем как реагировать на такой сигнал — дело, опять же, самого потока.
                    Получив его, поток может выполнить некоторые операции и завершить выполнение, а может и вовсе его проигнорировать и продолжить выполняться.
                    Описание реакции на сигнал завершения потока лежит на плечах программиста.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    <Text code>Java</Text> имеет встроенный механизм оповещения потока, который называется <Text code>Interruption</Text> (прерывание, вмешательство),
                    и скоро мы его рассмотрим, но сначала посмотрите на следующую програ
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    <Text code>Incremenator</Text> — поток, который каждую секунду прибавляет или вычитает единицу из значения статической переменной <Text code>Program.mValue</Text>.
                    <Text code>Incremenator</Text> содержит два закрытых поля – <Text code>mIsIncrement</Text> и <Text code>mFinish</Text>.
                    То, какое действие выполняется, определяется булевой переменной <Text code>mIsIncrement</Text> — если оно равно <Text code>true</Text>,
                    то выполняется прибавление единицы, иначе — вычитание. А завершение потока происходит, когда значение <Text code>mFinish</Text> становится равно <Text code>true</Text>.
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"class Incremenator extends Thread {\n" +
                    "    //О ключевом слове volatile - чуть ниже\n" +
                    "    private volatile boolean mIsIncrement = true;\n" +
                    "    private volatile boolean mFinish = false;\n" +
                    "\n" +
                    "    public void changeAction() {\n" +
                    "        mIsIncrement = !mIsIncrement;\n" +
                    "    }\n" +
                    "\n" +
                    "    public void finish() {\n" +
                    "        mFinish = true;\n" +
                    "    }\n" +
                    "\n" +
                    "    @Override\n" +
                    "    public void run() {\n" +
                    "        do {\n" +
                    "            if (!mFinish) {\n" +
                    "                if (mIsIncrement)\n" +
                    "                    Volatile.mValue++;    //Инкремент\n" +
                    "                else\n" +
                    "                    Volatile.mValue--;    //Декремент\n" +
                    "\n" +
                    "                //Вывод текущего значения переменной\n" +
                    "                System.out.print(Volatile.mValue + \" \");\n" +
                    "            } else\n" +
                    "                return;        //Завершение потока\n" +
                    "\n" +
                    "            try {\n" +
                    "                Thread.sleep(1000);        //Приостановка потока на 1 сек.\n" +
                    "            } catch (InterruptedException e) {\n" +
                    "            }\n" +
                    "        }\n" +
                    "        while (true);\n" +
                    "    }\n" +
                    "}\n" +
                    "\n" +
                    "public class Volatile {\n" +
                    "    //Переменая, которой оперирует инкременатор\n" +
                    "    public static int mValue = 0;\n" +
                    "\n" +
                    "    static Incremenator mInc;    //Объект побочного потока\n" +
                    "\n" +
                    "    public static void main(String[] args) {\n" +
                    "        mInc = new Incremenator();    //Создание потока\n" +
                    "\n" +
                    "        System.out.print(\"Значение = \");\n" +
                    "\n" +
                    "        mInc.start();    //Запуск потока\n" +
                    "\n" +
                    "        //Троекратное изменение действия инкременатора\n" +
                    "        //с интервалом в i*2 секунд\n" +
                    "        for (int i = 1; i <= 3; i++) {\n" +
                    "            try {\n" +
                    "                Thread.sleep(i * 2 * 1000); //Ожидание в течении i*2 сек.\n" +
                    "            } catch (InterruptedException e) {\n" +
                    "            }\n" +
                    "\n" +
                    "            mInc.changeAction();    //Переключение действия\n" +
                    "        }\n" +
                    "\n" +
                    "        mInc.finish();    //Инициация завершения побочного потока\n" +
                    "    }\n" +
                    "}"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    Взаимодействовать с потоком можно с помощью метода <Text code>changeAction()</Text> (для смены вычитания на сложение и наоборот)
                    и метода <Text code>finish()</Text> (для завершения потока).
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    В объявлении переменных <Text code>mIsIncrement</Text> и <Text code>mFinish</Text> было использовано ключевое слово <Text code>volatile</Text>
                    (изменчивый, не постоянный). Его необходимо использовать для переменных, которые используются разными потоками.
                    Это связано с тем, что значение переменной, объявленной без <Text code>volatile</Text>, может кэшироваться отдельно для каждого потока, и значение из этого кэша может различаться для каждого из них.
                    Объявление переменной с ключевым словом <Text code>volatile</Text> отключает для неё такое кэширование и все запросы к переменной будут направляться непосредственно в память.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    В этом примере показано, каким образом можно организовать взаимодействие между потоками.
                    Однако есть одна проблема при таком подходе к завершению потока — <Text code>Incremenator</Text> проверяет значение поля <Text code>mFinish</Text> раз в секунду,
                    поэтому может пройти до секунды времени между тем, когда будет выполнен метод <Text code>finish()</Text>, и фактическим завершения потока.
                    Было бы замечательно, если бы при получении сигнала извне, метод <Text code>sleep()</Text> возвращал выполнение и поток незамедлительно начинал своё завершение.
                    Для выполнения такого сценария существует встроенное средство оповещения потока, которое называется <Text code>Interruption</Text>
                    (прерывание, вмешательство).
                </Paragraph>
                <Title>Interruption</Title>
                <Paragraph style={{fontSize: 20}}>
                    Класс <Text code>Thread</Text> содержит в себе скрытое булево поле, подобное полю <Text code>mFinish</Text> в программе <Text code>Incremenator</Text>,
                    которое называется флагом прерывания. Установить этот флаг можно вызвав метод <Text code>interrupt()</Text> потока. Проверить же, установлен ли этот флаг, можно двумя способами.
                    Первый способ — вызвать метод <Text code>bool isInterrupted()</Text> объекта потока, второй — вызвать статический метод <Text code>bool Thread.interrupted()</Text>.
                    Первый метод возвращает состояние флага прерывания и оставляет этот флаг нетронутым.
                    Второй метод возвращает состояние флага и сбрасывает его. Заметьте что <Text code>Thread.interrupted()</Text> —
                    статический метод класса <Text code>Thread</Text>, и его вызов возвращает значение флага прерывания того потока, из которого он был вызван.
                    Поэтому этот метод вызывается только изнутри потока и позволяет потоку проверить своё состояние прерывания.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Итак, вернемся к нашей программе. Механизм прерывания позволит нам решить проблему с засыпанием потока. У методов, приостанавливающих выполнение потока, таких как <Text code>sleep()</Text>, <Text code>wait()</Text> и <Text code>join()</Text>
                    есть одна особенность — если во время их выполнения будет вызван метод <Text code>interrupt()</Text> этого потока, они, не дожидаясь конца времени ожидания, сгенерируют исключение <Text code>InterruptedException</Text>.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Переделаем программу <Text code>Incremenator</Text> – теперь вместо завершения потока с помощью метода <Text code>finish()</Text> будем использовать стандартный метод <Text code>interrupt()</Text>.
                    А вместо проверки флага <Text code>mFinish</Text> будем вызывать метод <Text code>bool Thread.interrupted();</Text>
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"class Incremenator2 extends Thread {\n" +
                    "    private volatile boolean mIsIncrement = true;\n" +
                    "\n" +
                    "    public void changeAction() {\n" +
                    "        mIsIncrement = !mIsIncrement;\n" +
                    "    }\n" +
                    "\n" +
                    "    @Override\n" +
                    "    public void run() {\n" +
                    "        do {\n" +
                    "            if (!Thread.interrupted()) {\n" +
                    "                if (mIsIncrement) Interrupt.mValue++;    //Инкремент\n" +
                    "                else Interrupt.mValue--;            //Декремент\n" +
                    "\n" +
                    "                //Вывод текущего значения переменной\n" +
                    "                System.out.print(Interrupt.mValue + \" \");\n" +
                    "            } else\n" +
                    "                return;        //Завершение потока\n" +
                    "\n" +
                    "            try {\n" +
                    "                Thread.sleep(1000);        //Приостановка потока на 1 сек.\n" +
                    "            } catch (InterruptedException e) {\n" +
                    "                return;    //Завершение потока после прерывания\n" +
                    "            }\n" +
                    "        }\n" +
                    "        while (true);\n" +
                    "    }\n" +
                    "}\n" +
                    "\n" +
                    "class Interrupt {\n" +
                    "    //Переменая, которой оперирует инкременатор\n" +
                    "    public static int mValue = 0;\n" +
                    "\n" +
                    "    static Incremenator2 mInc;    //Объект побочного потока\n" +
                    "\n" +
                    "    public static void main(String[] args) {\n" +
                    "        mInc = new Incremenator2();    //Создание потока\n" +
                    "\n" +
                    "        System.out.print(\"Значение = \");\n" +
                    "\n" +
                    "        mInc.start();    //Запуск потока\n" +
                    "\n" +
                    "        //Троекратное изменение действия инкременатора\n" +
                    "        //с интервалом в i*2 секунд\n" +
                    "        for (int i = 1; i <= 3; i++) {\n" +
                    "            try {\n" +
                    "                Thread.sleep(i * 2 * 1000);        //Ожидание в течении i*2 сек.\n" +
                    "            } catch (InterruptedException e) {\n" +
                    "            }\n" +
                    "\n" +
                    "            mInc.changeAction();    //Переключение действия\n" +
                    "        }\n" +
                    "\n" +
                    "        mInc.interrupt();    //Прерывание побочного потока\n" +
                    "    }\n" +
                    "}"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    Как видите, мы избавились от метода <Text code>finish()</Text> и реализовали тот же механизм завершения потока с помощью встроенной системы прерываний.
                    В этой реализации мы получили одно преимущество — метод <Text code>sleep()</Text> вернет управление (сгенерирует исключение) незамедлительно после прерывания потока.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Заметьте что методы <Text code>sleep()</Text> и <Text code>join()</Text> обёрнуты в конструкции <Text code>try-catch</Text>.
                    Это необходимое условие работы этих методов. Вызывающий их код должен перехватывать исключение <Text code>InterruptedException</Text>,
                    которое они бросают при прерывании во время ожидания.
                </Paragraph>
                <Title>Метод Thread.sleep()</Title>
                <Paragraph style={{fontSize: 20}}>
                    <Text code>Thread.sleep()</Text> — статический метод класса <Text code>Thread</Text>, который приостанавливает выполнение потока,
                    в котором он был вызван. Во время выполнения метода <Text code>sleep()</Text> система перестает выделять потоку процессорное время,
                    распределяя его между другими потоками. Метод <Text code>sleep()</Text> может выполняться либо заданное кол-во времени (миллисекунды или наносекунды)
                    либо до тех пор пока он не будет остановлен прерыванием (в этом случае он сгенерирует исключение <Text code>InterruptedException</Text>).
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"Thread.sleep(1500); \t\t//Ждет полторы секунды\n" +
                    "Thread.sleep(2000, 100);  \t//Ждет 2 секунды и 100 наносекунд"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    Несмотря на то, что метод sleep() может принимать в качестве времени ожидания наносекунды, не стоит принимать это всерьез. Во многих системах время ожидания все равно округляется до миллисекунд а то и до их десятков.
                </Paragraph>
                <Title>wait()</Title>
                <Paragraph style={{fontSize: 20}}>
                    Иногда в программе может оказаться такая ситуация, что нить вошла в блок кода synchronized, заблокировала монитор и не может работать дальше, т.к. каких-то данных еще не хватает: например, файл который она должна обработать еще не загрузился или что-нибудь в таком духе.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Мы же можем просто подождать, когда файл скачается. Можно просто в цикле проверять – если файл еще не скачался – спать, например, секунду и опять проверять и т.д.
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"while(!file.isDownloaded())\n" +
                    "{\n" +
                    " Thread.sleep(1000);\n" +
                    "}\n" +
                    "processFile(file);"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    Но в нашем случае такое ожидание слишком дорого. Т.к. наша нить заблокировала монитор, то другие нити вынуждены тоже ждать, хотя их данные для работы могут быть уже готовы.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Для решения этой проблемы и был придуман метод <Text code>wait()</Text>. Вызов этого метода приводит к тому, что нить освобождает монитор и «становится на паузу».
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Метод <Text code>wait</Text> можно вызвать у объекта-монитора и только тогда, когда это монитор занят – т.е. внутри блока <Text code>synchronized</Text>. При этом нить временно прекращает работу, а монитор освобождается, чтобы им могли воспользоваться другие нити.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Часто встречаются ситуации, когда в блок synchronized зашла нить, вызвала там wait, освободила монитор.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Затем туда вошла вторая нить и тоже стала на паузу, затем третья и так далее.
                </Paragraph>
                <Title>notify/notifyAll</Title>
                <Paragraph style={{fontSize: 20}}>
                    Методы notify/notifyAll можно вызвать у объекта-монитора и только, когда этот монитор занят – т.е. внутри блока synchronized. Метод notifyAll снимает с паузы все нити, которые стали на паузу с помощью данного объекта-монитора.
                </Paragraph>
                <Title>Метод yield()</Title>
                <Paragraph style={{fontSize: 20}}>
                    Статический метод <Text code>Thread.yield()</Text> заставляет процессор переключиться на обработку
                    других потоков системы. Метод может быть полезным, например, когда поток ожидает наступления какого-либо события и необходимо чтобы проверка его наступления происходила как можно чаще.
                    В этом случае можно поместить проверку события и метод <Text code>Thread.yield()</Text> в цикл:
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"//Ожидание поступления сообщения\n" +
                    "while(!msgQueue.hasMessages()) {\t\t//Пока в очереди нет сообщений\n" +
                    "\tThread.yield();\t\t//Передать управление другим потокам\n" +
                    "}"}
                </SyntaxHighlighter>
                <Title>Метод join()</Title>
                <Paragraph style={{fontSize: 20}}>
                    В <Text code>Java</Text> предусмотрен механизм, позволяющий одному потоку ждать завершения выполнения другого.
                    Для этого используется метод <Text code>join()</Text>.
                    Например, чтобы главный поток подождал завершения побочного потока <Text code>myThready</Text>,
                    необходимо выполнить инструкцию <Text code>myThready.join()</Text> в главном потоке.
                    Как только поток <Text code>myThready</Text> завершится, метод <Text code>join()</Text> вернет управление,
                    и главный поток сможет продолжить выполнение.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Метод <Text code>join()</Text> имеет перегруженную версию,
                    которая получает в качестве параметра время ожидания.
                    В этом случае <Text code>join()</Text> возвращает управление либо когда завершится ожидаемый поток,
                    либо когда закончится время ожидания. Подобно методу <Text code>Thread.sleep()</Text> метод <Text code>join</Text>
                    может ждать в течение миллисекунд и наносекунд – аргументы те же.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    С помощью задания времени ожидания потока можно, например, выполнять обновление анимированной картинки пока главный (или любой другой) поток ждёт завершения побочного потока, выполняющего ресурсоёмкие операции:
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"Thinker brain = new Thinker(); \t//Thinker - потомок класса Thread.\n" +
                    "brain.start();\t\t//Начать \"обдумывание\".\n" +
                    "\n" +
                    "do {\n" +
                    "\tmThinkIndicator.refresh();\t\t//mThinkIndicator - анимированная картинка.\n" +
                    "\n" +
                    "\ttry{\n" +
                    "\t\tbrain.join(250);\t\t\t\t//Подождать окончания мысли четверть секунды.\n" +
                    "\t}catch(InterruptedException e){}\n" +
                    "}\n" +
                    "while(brain.isAlive());\t//Пока brain думает...\n" +
                    "\n" +
                    "//brain закончил думать (звучат овации)."}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    В этом примере поток brain (мозг) думает над чем-то, и предполагается, что это занимает у него длительное время. Главный поток ждет его четверть секунды и, в случае, если этого времени на раздумье не хватило, обновляет «индикатор раздумий» (некоторая анимированная картинка). В итоге, во время раздумий, пользователь наблюдает на экране индикатор мыслительного процесса, что дает ему знать, что электронные мозги чем то заняты.
                </Paragraph>
                <Title>Приоритеты потоков</Title>
                <Paragraph style={{fontSize: 20}}>
                    Каждый поток в системе имеет свой приоритет. Приоритет – это некоторое число в объекте потока, более высокое значение которого означает больший приоритет. Система в первую очередь выполняет потоки с большим приоритетом, а потоки с меньшим приоритетом получают процессорное время только тогда, когда их более привилегированные собратья простаивают.
                    <ul>
                        <li><Text code>void setPriority(int priority)</Text> – устанавливает приоритет потока.
                            Возможные значения priority — <Text code>MIN_PRIORITY</Text>, <Text code>NORM_PRIORITY</Text> и <Text code>MAX_PRIORITY</Text>.
                        </li>
                        <li><Text code>int getPriority()</Text> – получает приоритет потока.</li>
                    </ul>
                </Paragraph>
                <Title>Volatile</Title>
                <Paragraph style={{fontSize: 20}}>
                    Модификатор volatile накладывает некоторые дополнительные условия на чтение/запись переменной. Важно понять две вещи о volatile переменных:
                    <ul>
                        <li>Операции чтения/записи volatile переменной являются атомарными.</li>
                        <li>Результат операции записи значения в volatile переменную одним потоком, становится виден всем другим потокам, которые используют эту переменную для чтения из нее значения.</li>
                    </ul>
                </Paragraph>
                <Title>Некоторые полезные методы класса Thread</Title>
                <Paragraph style={{fontSize: 20}}>
                    <ul>
                        <li>
                            <Text code>boolean isAlive()</Text> — возвращает <Text code>true</Text> если <Text code>myThready()</Text> выполняется и <Text code>false</Text> если поток еще не был запущен или был завершен.
                        </li>
                        <li><Text code>setName(String threadName)</Text> – Задает имя потока.</li>
                        <li><Text code>String getName()</Text> – Получает имя потока.</li>
                        <li>Имя потока – ассоциированная с ним строка, которая в некоторых случаях помогает понять, какой поток выполняет некоторое действие. Иногда это бывает полезным.</li>
                        <li><Text code>static Thread Thread.currentThread()</Text> — статический метод, возвращающий объект потока, в котором он был вызван.</li>
                        <li><Text code>long getId()</Text> – возвращает идентификатор потока. Идентификатор – уникальное число, присвоенное потоку.</li>
                    </ul>
                </Paragraph>
                <Title>Synchronized</Title>
                <Paragraph style={{fontSize: 20}}>
                    Это ключевое слово, которое позволяет заблокировать доступ к методу или части кода, если его уже использует другой поток. Другой поток ждет
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Если один поток зашел внутрь блока кода, который помечен словом synchronized, он моментально захватывает мьютекс объекта, и все другие потоки, которые попытаются зайти в этот же блок или метод вынуждены ждать, пока предыдущий поток не завершит свою работу и не освободит монитор
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    <Text strong>Монитор</Text> - это специальный объект, который следит за "состоянием" метода или объекта. Он смотрит, "занят" он или "свободен" в данный момент.
                    Дополнительная «надстройка» над мьютексом. Монитор — это «невидимый» для программиста кусок кода.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    <Text strong>Атомарный</Text> - значит "неделимый" - в том смысле, что операция может быть завершена одним потоком, и другой не может в ней ничего "напортить".
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Недостатком использования <Text code>synchronized</Text> является как раз то, что другие потоки вынуждены ждать, пока нужный объект или метод освободится. Это создает так называемый "bottle neck" ("узкое место") в программе - и скорость работы может пострадать.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    <Text strong>Мьютекс</Text> — обеспечить такой механизм, чтобы доступ к объекту в определенное время был только у одного потока. Если Поток-1 захватил мьютекс объекта А, остальные потоки не получат к нему доступ, чтобы что-то в нем менять. До тех пор, пока мьютекс объекта А не освободится, остальные потоки будут вынуждены ждать.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Пример из жизни: представь, что ты и еще 10 незнакомых людей участвуете в тренинге. Вам нужно поочередно высказывать идеи и что-то обсуждать. Но, поскольку друг друга вы видите впервые, чтобы постоянно не перебивать друг друга и не скатываться в гвалт, вы используете правило c «говорящим мячиком»: говорить может только один человек — тот, у кого в руках мячик.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Так вот, мьютекс, по сути, и есть такой мячик. Если мьютекс объекта находится в руках одного потока, другие потоки не смогут получить доступ к работе с этим объектом. Прямой доступ к нему есть только у Java-машины. Программисты же работают с мьютексами с помощью средств языка.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Не нужно ничего делать, чтобы создать мьютекс: он уже встроен в класс <Text code>Object</Text>, а значит, есть у каждого объекта в <Text code>Java</Text>.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Можно синхронизировать целый метод или если внутри метода нам нужно чтобы только часть кода была синхронизированной то тогда синхронизируем блок
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"public void swap() {\n" +
                    "   synchronized (this) {\n" +
                    "//...логика метода\n" +
                    "   }\n" +
                    "}"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    Обрати внимание: синхронизация проводится по <Text code>this</Text>. То есть по конкретному объекту <Text code>MyClass</Text>.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Представь, что у нас есть 2 потока (<Text code>Thread-1</Text> и <Text code>Thread-2</Text>) и всего один объект <Text code>MyClass myClass</Text>.
                    В этом случае, если <Text code>Thread-1</Text> вызовет метод <Text code>myClass.swap()</Text>, мьютекс объекта будет занят, и <Text code>Thread-2</Text> при попытке вызвать <Text code>myClass.swap()</Text>
                    повиснет в ожидании, когда мьютекс освободится.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Если же у нас будет 2 потока и 2 объекта <Text code>MyClass myClass1</Text> и <Text code>myClass2</Text> — на разных объектах наши потоки спокойно смогут одновременно выполнять синхронизированные методы.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Если метод статический то можно синхронизироваться по классу
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"class MyClass {\n" +
                    "   private static String name1 = \"Оля\";\n" +
                    "   private static String name2 = \"Лена\";\n" +
                    "\n" +
                    "   public static void swap() {\n" +
                    "       synchronized (MyClass.class) {\n" +
                    "           String s = name1;\n" +
                    "           name1 = name2;\n" +
                    "           name2 = s;\n" +
                    "       }\n" +
                    "   }\n" +
                    "}"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    В блоке кода, который помечен словом <Text code>synchronized</Text>, происходит захват мьютекса нашего объекта, а в данном случае класса <Text code>MyClass.class</Text>.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Хорошо, захват-то происходит, но как именно обеспечивается «защитный механизм»? Почему при виде слова <Text code>synchronized</Text> остальные потоки не могут пройти внутрь блока?
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Защитный механизм создает именно монитор! Компилятор преобразует слово <Text code>synchronized</Text> в несколько специальных кусков кода
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Мьютекс это способность объекта, а монитор его реализация, под капотом <Text code>synchronized</Text> происходит следущее:
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"public class Main {\n" +
                    "   private ObjectJava obj = new ObjectJava();\n" +
                    "\n" +
                    "   public void doSomething() throws InterruptedException {\n" +
                    "//...какая-то логика, доступная для всех потоков\n" +
                    "//логика, которая одновременно доступна только для одного потока:\n" +
                    "/*до тех пор, пока мьютекс объекта занят -\n" +
                    "       любой другой поток (кроме того, который его захватил), спит*/\n" +
                    "\n" +
                    "       while (obj.getMutex().isBusy()) {\n" +
                    "           Thread.sleep(1);\n" +
                    "       }\n" +
                    "//пометить мьютекс объекта как занятый\n" +
                    "       obj.getMutex().isBusy() = true;\n" +
                    "/*выполнить важную работу, при которой доступ к объекту\n" +
                    "       должен быть только у одного потока*/\n" +
                    "       obj.someImportantMethod();\n" +
                    "//освободить мьютекс объекта\n" +
                    "       obj.getMutex().isBusy() = false;\n" +
                    "   }\n" +
                    "}"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    Пример, конечно, ненастоящий. Здесь мы с помощью Java-подобного кода попытались отразить то, что происходит в этот момент внутри Java-машины.
                    Однако этот псевдокод дает отличное понимание того, что на самом деле происходит с объектом и потоками внутри блока <Text code>synchronized</Text> и как компилятор преобразует это слово в несколько «невидимых» для программиста команд.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    По сути, монитор в <Text code>Java</Text> выражен с помощью слова <Text code>synchronized</Text>. Весь код, который появился вместо слова <Text code>synchronized</Text> в последнем примере, — это и есть монитор.
                </Paragraph>
                <Title>Семафор</Title>
                <Paragraph style={{fontSize: 20}}>
                    Это средство для синхронизации доступа к какому-то ресурсу.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Его особенность заключается в том, что при создании механизма синхронизации он использует счетчик. Счетчик указывает нам, сколько потоков одновременно могут получать доступ к общему ресурсу.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                     Семафоры представлены классом <Text code>Semaphore</Text>. При создании объектов-семафоров мы можем использовать такие конструкторы:
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"Semaphore(int permits)\n" +
                    "Semaphore(int permits, boolean fair)"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    В конструктор мы передаем:
                    <ul>
                        <li>
                            <Text code>int permits</Text> — начальное и максимальное значение счетчика. То есть то, сколько потоков одновременно могут иметь доступ к общему ресурсу;
                        </li>
                        <li>
                            <Text code>boolean fair</Text> — для установления порядка, в котором потоки будут получать доступ. Если <Text code>fair = true</Text>, доступ предоставляется ожидающим потокам в том порядке, в котором они его запрашивали. Если же он равен <Text code>false</Text>, порядок будет определять планировщик потоков.
                        </li>
                    </ul>
                </Paragraph>
                <Title level={2}>Задача об обедающих философах</Title>
                <Paragraph style={{fontSize: 20}}>
                    классический пример, используемый для иллюстрации проблем синхронизации.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Пять безмолвных философов сидят вокруг круглого стола, перед каждым философом стоит тарелка спагетти. Вилки лежат на столе между каждой парой ближайших философов.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Каждый философ может либо есть, либо размышлять. Приём пищи не ограничен количеством оставшихся спагетти — подразумевается бесконечный запас. Тем не менее, философ может есть только тогда, когда держит две вилки — взятую справа и слева (альтернативная формулировка проблемы подразумевает миски с рисом и палочки для еды вместо тарелок со спагетти и вилок).
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Каждый философ может взять ближайшую вилку (если она доступна) или положить — если он уже держит её. Взятие каждой вилки и возвращение её на стол являются раздельными действиями, которые должны выполняться одно за другим.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Вопрос задачи заключается в том, чтобы разработать модель поведения (параллельный алгоритм), при котором ни один из философов не будет голодать, то есть будет вечно чередовать приём пищи и размышления.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Задача сформулирована таким образом, чтобы иллюстрировать проблему избежания взаимной блокировки (англ. deadlock) — состояния системы, при котором прогресс невозможен. Пример:
                </Paragraph>
                <Image src={blocked} />
                <Paragraph style={{fontSize: 20}}>
                    Например, можно посоветовать каждому философу выполнять следующий алгоритм:
                    <ul>
                        <li>Размышлять, пока не освободится левая вилка. Когда вилка освободится — взять её.</li>
                        <li>Размышлять, пока не освободится правая вилка. Когда вилка освободится — взять её.</li>
                        <li>Есть</li>
                        <li>Положить левую вилку</li>
                        <li>Положить правую вилку</li>
                        <li>Повторить алгоритм сначала</li>
                    </ul>
                    Это решение задачи некорректно: оно позволяет системе достичь состояния взаимной блокировки, когда каждый философ взял вилку слева и ждёт, когда вилка справа освободится
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"class Philosopher extends Thread {\n" +
                    "   private Semaphore sem;\n" +
                    "// поел ли философ\n" +
                    "   private boolean full = false;\n" +
                    "   private String name;\n" +
                    "   Philosopher(Semaphore sem, String name) {\n" +
                    "       this.sem=sem;\n" +
                    "       this.name=name;\n" +
                    "   }\n" +
                    "   public void run() {\n" +
                    "       try {\n" +
                    "// если философ еще не ел\n" +
                    "           if (!full) {\n" +
                    "//Запрашиваем у семафора разрешение на выполнение\n" +
                    "               sem.acquire();\n" +
                    "               System.out.println (name + \" садится за стол\");\n" +
                    "// философ ест\n" +
                    "               sleep(300);\n" +
                    "               full = true;\n" +
                    "               System.out.println (name + \" поел! Он выходит из-за стола\");\n" +
                    "               sem.release();\n" +
                    "// философ ушел, освободив место другим\n" +
                    "               sleep(300);\n" +
                    "           }\n" +
                    "       }\n" +
                    "       catch(InterruptedException e) {\n" +
                    "           System.out.println (\"Что-то пошло не так!\");\n" +
                    "       }\n" +
                    "   }\n" +
                    "}"}
                </SyntaxHighlighter>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"public class Main {\n" +
                    "\n" +
                    "   public static void main(String[] args) {\n" +
                    "\n" +
                    "       Semaphore sem = new Semaphore(2);\n" +
                    "       new Philosopher(sem,\"Сократ\").start();\n" +
                    "       new Philosopher(sem,\"Платон\").start();\n" +
                    "       new Philosopher(sem,\"Аристотель\").start();\n" +
                    "       new Philosopher(sem,\"Фалес\").start();\n" +
                    "       new Philosopher(sem,\"Пифагор\").start();\n" +
                    "   }\n" +
                    "}"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    Мы создали семафор со счетчиком 2, чтобы одновременно ели только два философа. То есть, одновременно работать могут только два потока, ведь наш класс <Text code>Philosopher</Text> унаследован от <Text code>Thread</Text>!
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Методы <Text code>acquire()</Text> и <Text code>release()</Text> класса <Text code>Semaphore</Text> управляют его счетчиком разрешений.
                    Метод <Text code>acquire()</Text> запрашивает разрешение на доступ к ресурсу у семафора. Если счетчик {"> 0"}, разрешение предоставляется, а счетчик уменьшается на 1.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Метод <Text code>release()</Text> «освобождает» выданное ранее разрешение и возвращает его в счетчик (увеличивает счетчик разрешений семафора на 1).
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    На самом деле мьютекс — это одноместный семафор. То есть, это семафор, счетчик которого изначально установлен в значении 1. Его еще называют «двоичным семафором», поскольку его счетчик может иметь только 2 значения — 1 («свободно») и 0 («занято»).
                </Paragraph>
            </Typography>)
    }
}