import React from 'react';
import 'antd/dist/antd.css';
import {Typography} from 'antd';
import SyntaxHighlighter from "react-syntax-highlighter";
import {darcula} from "react-syntax-highlighter/dist/esm/styles/hljs";

const {Paragraph, Text} = Typography;

export default class Kafka extends React.Component {
    render() {
        return (
            <Typography>
                <Paragraph style={{fontSize: 20}}>
                    Apache Kafka является брокером сообщений. С его помощью микросервисы могут взаимодействовать друг с другом, посылая и получая важную информацию. Возникает вопрос, почему не использовать для этих целей обычный POST – reqest, в теле которого можно передать нужные данные и таким же образом получить ответ? У такого подхода есть ряд очевидных минусов. Например, продюсер (сервис, отправляющий сообщение) может отправить данные только в виде response’а в ответ на запрос консьюмера (сервиса, получающего данные). Допустим, консьюмер отправляет POST – запрос, и продюсер отвечает на него. В это время консьюмер по каким-то причинам не может принять полученный ответ. Что будет с данными? Они будут потеряны. Консьюмеру снова придётся отправлять запрос и надеяться, что данные, которые он хотел получить, за это время не изменились, и продюсер всё ещё готов принять request.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Apache Zookeeper – это централизованная служба для поддержки информации о конфигурации, обеспечения синхронизации распределенных приложений. За счет своего API, Зукипер берет на себя координацию распределенных сервисов, позволяя разработчику сосредоточиться на логике своего приложения.
                    Zoo стал стандартом де-факто для отслеживания состояния распределенных данных, синхронизации приложений и координации всего кластерастатического контекста.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Зукипер информирует каждого брокера Kafka о текущем состоянии кластера. Благодаря этого каждому клиенту Kafka (издателю/подписчику) нужно всего лишь подключиться к какому-либо брокеру, а обновление метаданных у него произойдет автоматически
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Таким образом, Зукипер нужен Кафке для обеспечения надежной согласованности состояния кластера
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Другим важным моментом является то, что вы НЕ можете переопределять (Override) статические методы.
                    Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса (superclass)
                    вместо переопределения. Это явление известно как сокрытие методов (hiding methods).
                    Это означает, что при обращении к статическому методу, который объявлен как в родительском, так и в дочернем классе,
                    во время компиляции всегда будет вызван метод исходя из типа переменной. В отличие от переопределения, такие методы не будут выполнены во время работы программы. Рассмотрим пример:
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"class Vehicle{\n" +
                    "     public static void  kmToMiles(int km){\n" +
                    "          System.out.println(\"Внутри родительского класса/статического метода\");\n" +
                    "     } }\n" +
                    "\n" +
                    "class Car extends Vehicle{\n" +
                    "     public static void  kmToMiles(int km){\n" +
                    "          System.out.println(\"Внутри дочернего класса/статического метода \");\n" +
                    "     } }\n" +
                    "\n" +
                    "public class Demo{\n" +
                    "   public static void main(String args[]){\n" +
                    "      Vehicle v = new Car();\n" +
                    "       v.kmToMiles(10);\n" +
                    "  }}"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    Код наглядно демонстрирует: несмотря на то, что объект имеет
                    тип <Text code>Car</Text>, вызван статический метод из класса <Text code>Vehicle</Text>,
                    т.к. произошло обращение к методу во время компиляции. И заметьте, ошибки во время компиляции не возникло!
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Объявить статическим также можно и класс, за исключением классов верхнего уровня.
                    Такие классы известны как «вложенные статические классы» (nested static class).
                    Они бывают полезными для представления улучшенных связей. Яркий пример вложенного статического класса — <Text code>HashMap.Entry</Text>,
                    который предоставляет структуру данных внутри <Text code>HashMap</Text>.
                    Стоит заметить, также как и любой другой внутренний класс, вложенные классы находятся в отдельном файле <Text code>.class</Text>.
                    Таким образом, если вы объявили пять вложенных классов в вашем главном классе, у вас будет 6 файлов с расширением <Text code>.class</Text>.
                    Ещё одним примером использования является объявление собственного компаратора (Comparator), например компаратор по возрасту (AgeComparator) в классе сотрудники (Employee).
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Модификатор <Text code>static</Text> также может быть объявлен в статичном блоке, более известным как «Статический блок инициализации» (Static initializer block),
                    который будет выполнен во время загрузки класса. Если вы не объявите такой блок, то <Text code>Java</Text> соберёт все статические поля в один список и
                    выполнит его во время загрузки класса. Однако, статичный блок НЕ может пробросить перехваченные исключения, но может выбросить не перехваченные.
                    В таком случае возникнет «Exception Initializer Error». На практике, любое исключение возникшее во время выполнения и инициализации статических полей, будет завёрнуто <Text code>Java</Text> в эту ошибку.
                    Это также самая частая причина ошибки «No Class Def Found Error», т.к. класс не находился в памяти во время обращения к нему.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Полезно знать, что статические методы связываются во время компиляции, в отличие от связывания виртуальных или не статических методов,
                    которые связываются во время исполнения на реальном объекте. Следовательно, статические методы не могут быть переопределены,
                    т.к. полиморфизм во время выполнения не распространяется на них. Это важное ограничение, которое необходимо учитывать, объявляя метод статическим.
                    В этом есть смысл, только тогда, когда нет возможности или необходимости переопределения такого метода классами-наследниками. Методы-фабрики и методы-утилиты хорошие образцы применения модификатора <Text code>static</Text>.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Важным свойством статического блока является инициализация.
                    Статические поля или переменные инициализируются после загрузки класса в память.
                    Порядок инициализации сверху вниз, в том же порядке, в каком они описаны в исходном файле класса.
                    Поскольку статические поля инициализируются на потокобезопасный манер, это свойство также используется для реализации паттерна <Text code>Singleton</Text>.
                    Если вы не используется список <Text code>Enum</Text> как <Text code>Singleton</Text>, по тем или иным причинам, то для вас есть хорошая альтернатива.
                    Но в таком случае необходимо учесть, что это не «ленивая» инициализация. Это означает, что статическое поле будет проинициализировано ещё ДО того как кто-нибудь об этом «попросит».
                    Если объект ресурсоёмкий или редко используется, то инициализация его в статическом блоке сыграет не в вашу пользу.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Во время сериализации, также как и <Text code>transient</Text> переменные, статические поля не сериализуются.
                    Действительно, если сохранить любые данные в статическом поле, то после десериализации новый объект будет содержать его первичное (по-умолчанию) значение, например, если статическим полем была переменная типа <Text code>int</Text>,
                    то её значение после десериализации будет равно нулю, если типа <Text code>float</Text> – 0.0, если типа <Text code>Object</Text> – <Text code>null</Text>.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    И напоследок, поговорим о <Text code>static import</Text>.
                    Данный модификатор имеет много общего со стандартным оператором <Text code>import</Text>,
                    но в отличие от него позволяет импортировать один или все статические члены класса.
                    При импортировании статических методов, к ним можно обращаться как будто они определены в этом же классе,
                    аналогично при импортировании полей, мы можем получить доступ без указания имени класса. Данная возможность появилась в <Text code>Java</Text> версии 1.5, и при должном использовании улучшает читабельность кода.
                    Наиболее часто данная конструкция встречается в тестах <Text code>JUnit</Text>, т.к. почти все разработчики тестов используют <Text code>static import</Text> для <Text code>assert</Text> методов, например <Text code>assertEquals()</Text> и для их перегруженных дубликатов.
                </Paragraph>
            </Typography>)
    }
}