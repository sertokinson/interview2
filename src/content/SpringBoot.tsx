import React from 'react';
import 'antd/dist/antd.css';
import {Typography} from 'antd';
import SyntaxHighlighter from "react-syntax-highlighter";
import {darcula} from "react-syntax-highlighter/dist/esm/styles/hljs";

const {Paragraph, Text} = Typography;

export default class SpringBoot extends React.Component {
    render() {
        return (
            <Typography>
                <Paragraph style={{fontSize: 20}}>
                    Теперь переходим к следующей части. Допустим, нам надо сконфигурить подключение к MySQL базе данных. Если мы хотим использовать Spring Data JPA с Hibernate в качестве провайдера, нам потребуется сконфигурировать несколько бинов — EntityManagerFactory (основной класс JPA), DataSource для подключения непосредственно к базе через JDBC драйвер и т.п. Но с другой стороны, если мы это делаем каждый раз и, по сути, делаем одно и то же — почему бы это не автоматизировать? Скажем, если мы указали строку подключения к базе и добавили зависимость на MySQL драйвер — почему бы чему-то автоматически не создать все нужные бины для работы с MySQL? Именно это и делает Spring Boot. По сути, Spring Boot это просто набор классов конфигурации, которые создают нужные бины в контексте. Точно так же их можно создать руками, просто Boot это автоматизирует.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                   <ul>
                       <li>Аннотация @SpringBootApplication включает сканирование компонентов и авто-конфигурацию через аннотацию @EnableAutoConfiguration</li>
                       <li>Каждая конфигурация пытается сконфигурить различные аспекты приложения (web, JPA, AMQP etc), регистрируя нужные бины и используя различные условия (наличие / отсутствие бина, настройки, класса и т.п.)</li>
                       <li>Servlet container запускается, приложение готово к работе!</li>
                   </ul>
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"public class Counter{\n" +
                    "private int count;\n" +
                    "public static void main(String args[]){\n" +
                    "   System.out.println(count); //compile time error\n" +
                    "}}"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    В отличие от локальных переменных, статические поля и методы НЕ потокобезопасны (Thread-safe).
                    На практике это одна из наиболее частых причин возникновения проблем связанных с безопасностью мультипоточного программирования.
                    Учитывая что каждый экземпляр класса имеет одну и ту же копию статической переменной, то такая переменная нуждается в защите — «залочивании» классом.
                    Поэтому при использовании статических переменных, убедитесь, что они должным образом синхронизированы (synchronized), во избежание проблем, например таких как «состояние гонки» (race condition).
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Статические методы имеют преимущество в применении, т.к. отсутствует необходимость каждый раз создавать новый объект для доступа к таким методам.
                    Статический метод можно вызвать, используя тип класса, в котором эти методы описаны. Именно поэтому, подобные методы как нельзя лучше подходят в качестве методов-фабрик (factory), и методов-утилит (utility).
                    Класс <Text code>java.lang.Math</Text> — замечательный пример, в котором почти все методы статичны, по этой же причине классы-утилиты в <Text code>Java</Text> финализированы (final).
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Другим важным моментом является то, что вы НЕ можете переопределять (Override) статические методы.
                    Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса (superclass)
                    вместо переопределения. Это явление известно как сокрытие методов (hiding methods).
                    Это означает, что при обращении к статическому методу, который объявлен как в родительском, так и в дочернем классе,
                    во время компиляции всегда будет вызван метод исходя из типа переменной. В отличие от переопределения, такие методы не будут выполнены во время работы программы. Рассмотрим пример:
                </Paragraph>
                <SyntaxHighlighter language="java" style={darcula}>
                    {"class Vehicle{\n" +
                    "     public static void  kmToMiles(int km){\n" +
                    "          System.out.println(\"Внутри родительского класса/статического метода\");\n" +
                    "     } }\n" +
                    "\n" +
                    "class Car extends Vehicle{\n" +
                    "     public static void  kmToMiles(int km){\n" +
                    "          System.out.println(\"Внутри дочернего класса/статического метода \");\n" +
                    "     } }\n" +
                    "\n" +
                    "public class Demo{\n" +
                    "   public static void main(String args[]){\n" +
                    "      Vehicle v = new Car();\n" +
                    "       v.kmToMiles(10);\n" +
                    "  }}"}
                </SyntaxHighlighter>
                <Paragraph style={{fontSize: 20}}>
                    Код наглядно демонстрирует: несмотря на то, что объект имеет
                    тип <Text code>Car</Text>, вызван статический метод из класса <Text code>Vehicle</Text>,
                    т.к. произошло обращение к методу во время компиляции. И заметьте, ошибки во время компиляции не возникло!
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Объявить статическим также можно и класс, за исключением классов верхнего уровня.
                    Такие классы известны как «вложенные статические классы» (nested static class).
                    Они бывают полезными для представления улучшенных связей. Яркий пример вложенного статического класса — <Text code>HashMap.Entry</Text>,
                    который предоставляет структуру данных внутри <Text code>HashMap</Text>.
                    Стоит заметить, также как и любой другой внутренний класс, вложенные классы находятся в отдельном файле <Text code>.class</Text>.
                    Таким образом, если вы объявили пять вложенных классов в вашем главном классе, у вас будет 6 файлов с расширением <Text code>.class</Text>.
                    Ещё одним примером использования является объявление собственного компаратора (Comparator), например компаратор по возрасту (AgeComparator) в классе сотрудники (Employee).
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Модификатор <Text code>static</Text> также может быть объявлен в статичном блоке, более известным как «Статический блок инициализации» (Static initializer block),
                    который будет выполнен во время загрузки класса. Если вы не объявите такой блок, то <Text code>Java</Text> соберёт все статические поля в один список и
                    выполнит его во время загрузки класса. Однако, статичный блок НЕ может пробросить перехваченные исключения, но может выбросить не перехваченные.
                    В таком случае возникнет «Exception Initializer Error». На практике, любое исключение возникшее во время выполнения и инициализации статических полей, будет завёрнуто <Text code>Java</Text> в эту ошибку.
                    Это также самая частая причина ошибки «No Class Def Found Error», т.к. класс не находился в памяти во время обращения к нему.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Полезно знать, что статические методы связываются во время компиляции, в отличие от связывания виртуальных или не статических методов,
                    которые связываются во время исполнения на реальном объекте. Следовательно, статические методы не могут быть переопределены,
                    т.к. полиморфизм во время выполнения не распространяется на них. Это важное ограничение, которое необходимо учитывать, объявляя метод статическим.
                    В этом есть смысл, только тогда, когда нет возможности или необходимости переопределения такого метода классами-наследниками. Методы-фабрики и методы-утилиты хорошие образцы применения модификатора <Text code>static</Text>.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Важным свойством статического блока является инициализация.
                    Статические поля или переменные инициализируются после загрузки класса в память.
                    Порядок инициализации сверху вниз, в том же порядке, в каком они описаны в исходном файле класса.
                    Поскольку статические поля инициализируются на потокобезопасный манер, это свойство также используется для реализации паттерна <Text code>Singleton</Text>.
                    Если вы не используется список <Text code>Enum</Text> как <Text code>Singleton</Text>, по тем или иным причинам, то для вас есть хорошая альтернатива.
                    Но в таком случае необходимо учесть, что это не «ленивая» инициализация. Это означает, что статическое поле будет проинициализировано ещё ДО того как кто-нибудь об этом «попросит».
                    Если объект ресурсоёмкий или редко используется, то инициализация его в статическом блоке сыграет не в вашу пользу.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    Во время сериализации, также как и <Text code>transient</Text> переменные, статические поля не сериализуются.
                    Действительно, если сохранить любые данные в статическом поле, то после десериализации новый объект будет содержать его первичное (по-умолчанию) значение, например, если статическим полем была переменная типа <Text code>int</Text>,
                    то её значение после десериализации будет равно нулю, если типа <Text code>float</Text> – 0.0, если типа <Text code>Object</Text> – <Text code>null</Text>.
                </Paragraph>
                <Paragraph style={{fontSize: 20}}>
                    И напоследок, поговорим о <Text code>static import</Text>.
                    Данный модификатор имеет много общего со стандартным оператором <Text code>import</Text>,
                    но в отличие от него позволяет импортировать один или все статические члены класса.
                    При импортировании статических методов, к ним можно обращаться как будто они определены в этом же классе,
                    аналогично при импортировании полей, мы можем получить доступ без указания имени класса. Данная возможность появилась в <Text code>Java</Text> версии 1.5, и при должном использовании улучшает читабельность кода.
                    Наиболее часто данная конструкция встречается в тестах <Text code>JUnit</Text>, т.к. почти все разработчики тестов используют <Text code>static import</Text> для <Text code>assert</Text> методов, например <Text code>assertEquals()</Text> и для их перегруженных дубликатов.
                </Paragraph>
            </Typography>)
    }
}